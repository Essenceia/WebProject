<br/><br/>
<div class = title ><h1> NATEC : an N Axis Tool Efficient Controller</h1></div>
<h2>I - Présentation : </h2>
<br/>
L’année dernière au mois de janvier, j’ai acheté une imprimante 3d, RepRap, que j’ai monté, pris en main, et amélioré tout au long de l’année. J’ai fait beaucoup de modifications mécanique pour améliorer ses performances, et beaucoup touché au slicer pour imprimer correctement.
<br/><br/>
La seule partie dont je n’avais pas eu d’aperçu était évidement le code, Marlin, projet libre de contrôleur pour les reprap, stable et ultra portable, adaptable à toutes sortes d’imprimantes.
<br/>
J’ai donc commencé à essayer de comprendre le fonctionnement de Marlin, mais ce fut … un échec cuisant, le code étant relativement compliqué (et mon niveau en C n’étant pas merveilleux à l’époque). J’ai donc entrepris de concevoir mon propre contrôleur de mouvement.
<br/><br/>
A l’heure actuelle, et à ma connaissance, le code libre le plus répandu et le plus performant dans le contrôle des CNC est GRBL. Marlin a d’ailleurs si je ne m’abuse un cœur GRBL. Cependant, ce contrôleur est très limité dans ces fonctions. En effet, il ne permet que de faire bouger des machines 4 axes, et l’ajout d’un axe rotatif (pour faire des pièces fraisées à révolution) est actuellement envisagée. Il ne permet pas non plus de tracer des courbes personnalisées, en se limitant actuellement aux arcs et spirales.
J’ai donc entrepris de concevoir un code offrant au moins les mêmes performances en terme de vitesse de déplacement, mais avec des fonctionnalités supplémentaires.
<br/><br/>
Un grand enjeu du code, était d’être adaptable au nombre d’axes. L’idée est de pouvoir contrôler d’une manière similaire une pick and place 6 axes, une découpeuse laser 3 axes, une fraiseuse 3 axes, ou un distributeurs de boissons (je ne plaisante pas, ceux-ci sont souvent contrôlés avec des moteurs pas à pas. De plus, il n’existe pas actuellement de contrôleur libre pour distributeurs de sodas, quelle tristesse!)
<br/><br/>
Un autre enjeu du code était de permettre le traçage de courbes atypiques, mais très utiles telles des courbes de Bézier ou des ellipses. Ces courbes sont souvent utilisées dans la découpe laser mais doivent être approximées par des lignes pendant la découpe, ce qui est une aberration, et que je voulais éviter à tout prix.
<br/><br/>
J'avais à ma disposition une Arduino Mega, munie d'une Carte élec de contrôle, une board RAMPS 1.4, utilisée dans les RepRap, permettant de contrôler jusqu'à cinq moteurs pas à pas en parallèle.
<br/><br/>
<img src="/layout/img/LL_ELEC_0.jpg" class="picture">
<br/><br/>
C’était il y a six mois.
<br/><br/>
<h2>II - Fonctionnalités : </h2>
<br/>
Aujourd’hui, NATEC (mon contrôleur de mouvements) comprend les fonctionnalités suivantes :
<br/><br/>
<h3>1 - Adaptabilité au nombre d’axes : </h3>
Il peut fonctionner sur n’importe quelle machine cartésienne (sur les machines polaires aussi théoriquement, ça sera certainement l’objet de mon projet de fin d’études, la différence étant uniquement dans la régulation de la vitesse) et ceci indépendamment du nombre d’axes, le code de mouvement pour chaque axe étant généré automatiquement à la compilation en fonction de fichiers de configuration. Il est donc, entre autres, tout à fait possible d’utiliser le code pour contrôler une fraiseuse munie d’un quatrième axe circulaire. Le seul problème résidera dans la régulation de la vitesse, qui sera impropre pour ce type de machine (polaires, non cartésiennes)
<br/><br/>
<h3>2 - Régulations : </h3>
La position et la vitesse sont évidement régulées. L'accélération est, elle, maintenue constante.
<br/><br/>
<h3>3 - Trajectoires linéaires optimisées : </h3>
Les mouvements linéaires (trait droit entre deux points de l’espace à N dimensions, N = nombre d’axes) sont optimisés, et peuvent aller jusqu’à (pour l’instant) 500mm/s à 80 tics/mm soit une fréquence maximale d’impulsion de 40kHz (sur un AVR 8 bit rappelons-le)
<br/><br/>
<h3>4 - Tracé en bas niveau de TOUTE courbe 2D : </h3>
Le code contient une classe permettant de tracer n’importe quelle trajectoire suffisamment douce (sans changement brutal de direction) en 2D, si on en connaît l’équation. La régulation de la vitesse et de l’accélération au départ et à l’arrivée sont déjà codées. Ceci comprend les ellipses, les courbes de Bézier (toutes deux déjà implémentées), ou encode les spirales. La vitesse maximale de tracé de la courbe dépend de la complexité de son équation, mais pour donner une  idée, les courbes de Bézier et les ellipses sont tracées sans aucun souci à 350mm/s à 80 tic/mm, soit 28 kHz, toujours sur un AVR 8 bit.
<br/><br/>
<h3>5 – Support des outils et actionneurs multiples : </h3>
Il est possible est très simple, d’ajouter un actionneur au code et de l’intégrer au comportement de la machine. Un actionneur peut être :
<br/>- Un actionneur commandé binairement (une ventilation par exemple) ;
<br/>- Un servomoteur, actionnant par exemple une pince sur la machine (notons que le code peut aussi commander des bras articulés)
<br/>- Un outil, qui à l’instar de l’actionneur binaire sera commandé linéairement (sur une échelle de valeurs entre 0 et la puissance maximale) . Par exemple, un laser, ou une fraise, par exemple, dont la puissance et (resp) la vitesse de rotation, doivent être régulées. La puissance fournie aux outils est réglable de deux manières : avec la vitesse, pour le laser par exemple, car la puissance émise par le laser doit dépendre de la vitesse de déplacement du chariot de découpe, et en absolu, pour la fraiseuse, par exemple, pour laquelle la vitesse de la fraise est constante peu importe que le chariot soit en mouvement ou à l’arrêt.
<br/><br/>
<h3>6 - Personnalisation du Parseur : </h3>
Le haut niveau d’adaptabilité du code à la machine impose une grande flexibilité au Parseur. Ce dernier est lui aussi personnalisable, que ce soit sur les commandes de mouvement (G_N) , préparatoires (M_N) ou les paramètres passés en argument. Ceci permet d’adapter entièrement le code à la machine (par exemple, ajouter une ventilation à la découpeuse laser), et d’adapter le Gcode de la machine à un standard donné.
<br/><br/>
<h3>7 - En développement : </h3>
Régulation de la vitesse par groupes d’axes cartésiens : la machine peut n’avoir qu’un seul chariot dont la position et la vitesse sont régulées (ex : découpeuse laser, imprimante 3D), dans ce cas, la régulation en vitesse est aisée : il suffit de réguler la norme du vecteur vitesse ||(v1, v2, .., vn)|| = sqrt(v1²+v2²+...+vn²). Par contre, dans le cas ou la machine comporte plusieurs chariots (ex : la pince à composants et le sélectionneur de composants dans une pick and place évoluée), la régulation par cette méthode est inexacte, car les vitesses des différents chariots sont calculées avec des parties du vecteur vitesse global. Il faut donc définir des groupes d’axes cartésiens, chacun pouvant être régulé en vitesse.
<br/><br/>
<h3>8 – Et ensuite ? </h3>
L’étape finale sera de rendre adaptable la régulation en vitesse. C’est ce point qui empêche pour l’instant d’avoir une régulation en vitesse propre sur un bras articulé par exemple. En effet, la vitesse du bout du bras dépend des vitesses de rotations, mais aussi des positions angulaires, positions impossibles, pour le moment, à prendre en compte. Ceci permettra aussi d’adapter le code aux fraiseuses polaires.
<br/><br/>
De plus, les performances actuelles (très correctes) sont réalisées sur une Arduino Méga (AVR 8 bit), à la puissance de calcul très faible donc. L’enjeu va aussi être de porter le code sur des architectures plus évoluées, permettant du calcul sur flottant en HardWare, ceci promettant d’augmenter massivement les performances du code.
<br/><br/>
<h2>III - Télécharger le code: </h2>
Le code est (bien entendu) libre, et disponible sur GitHub.
<br/><br/>
<a href="https://github.com/Briztou/NATEC"  download>
    <img src="/layout/img/git.png" style="width:100px;display: block;margin-left: auto;margin-right: auto">
</a>
<br/><br/>
<h2>IV - Documentation complète: </h2>
J'essaie de tenir à jour une documentation sur la théorie de l'algorithme. J'y détaille l'algorithme de mouvement, et les calculs relatifs à la position et la vitesse, ainsi que sa régulation.
<br/>
Quelques sections manquent encore, mais je le complète régulièrement.
<br/><br/>
<a href="/doc/NATEC.pdf" download>
    <img src="/layout/img/download.png" style="width:100px;display: block;margin-left: auto;margin-right: auto">
</a>
<h2>IV - Quelques démonstrations : </h2>
<h3>1 - Déplacements sur plusieurs axes : </h3>
<iframe width="900" height="520"  class = "video"
        src="https://www.youtube.com/embed/B5CdbEAydXg">
</iframe>
<h3>2 - Grandes vitesses : </h3>
<h3>3 - Trajectoires quelconques en 2D : </h3>
<h4>Exemple 3.1 - Ellipses lentes : </h4>
<br/><br/>
<iframe width="900" height="520" class = "video"
        src="https://www.youtube.com/embed/XP5KztLISrY">
</iframe>
<br/><br/>
<h4>Exemple 3.2 - Ellipses rapides: </h4>
<br/><br/>
<iframe width="900" height="520" class = "video"
        src="https://www.youtube.com/embed/5YXHg7j3yLY">
</iframe>
<br/><br/>
<h4>Exemple 3.3 - Courbes de Bézier : </h4>
<br/><br/>
<iframe width="900" height="520"  class = "video"
        src="https://www.youtube.com/embed/sqgGlTXsr8I">
</iframe>
